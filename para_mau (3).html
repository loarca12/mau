<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Para Mauu ðŸ’•</title>
    <link rel="icon" type="image/png" href="ruta-de-tu-imagen.jpeg">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #root {
            width: 100vw;
            height: 100vh;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
            85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- React and ReactDOM from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const { useState, useEffect, useRef, createElement: h } = React;
        const THREE = window.THREE;

        function ParaMau() {
            const containerRef = useRef(null);
            const [currentMessage, setCurrentMessage] = useState(0);
            const [showMessage, setShowMessage] = useState(false);
            const [isUserDragging, setIsUserDragging] = useState(false);
            const dragStartPos = useRef({ x: 0, y: 0 });

            const messages = [
                "Eres la razÃ³n de mi felicidad cada dÃ­a",
                "Nada pesa, nada se siente dificil",
                "Waffles â™¡",
                "Contigo, cada momento es especial",
                "Mi corazÃ³n late por ti",
                "Eres mi persona favorita en todo el universo",
                "Gracias por existir en mi vida",
                "Cada dÃ­a te quiero mÃ¡s",
                "Eres mi luz en la oscuridad",
                "Juntos somos infinito"
            ];

            useEffect(() => {
                if (!containerRef.current) return;

                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                
                renderer.setSize(window.innerWidth, window.innerHeight);
                containerRef.current.appendChild(renderer.domElement);

                // Heart particles
                const heartParticlesCount = 2000;
                const heartGeometry = new THREE.BufferGeometry();
                const heartPositions = new Float32Array(heartParticlesCount * 3);
                const heartColors = new Float32Array(heartParticlesCount * 3);
                const heartSizes = new Float32Array(heartParticlesCount);

                const getHeartPoint = (t) => {
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    const z = (Math.random() - 0.5) * 3;
                    return { x: x * 0.08, y: (y * 0.08) - 0.5, z: z * 0.08 };
                };

                for (let i = 0; i < heartParticlesCount; i++) {
                    const t = (i / heartParticlesCount) * Math.PI * 2;
                    const point = getHeartPoint(t);
                    
                    const spread = 0.3;
                    heartPositions[i * 3] = point.x + (Math.random() - 0.5) * spread;
                    heartPositions[i * 3 + 1] = point.y + (Math.random() - 0.5) * spread;
                    heartPositions[i * 3 + 2] = point.z + (Math.random() - 0.5) * spread;

                    const colorChoice = Math.random();
                    if (colorChoice < 0.5) {
                        heartColors[i * 3] = 1;
                        heartColors[i * 3 + 1] = 0.2 + Math.random() * 0.3;
                        heartColors[i * 3 + 2] = 0.6 + Math.random() * 0.2;
                    } else if (colorChoice < 0.8) {
                        heartColors[i * 3] = 1;
                        heartColors[i * 3 + 1] = 0.5 + Math.random() * 0.3;
                        heartColors[i * 3 + 2] = 0.7 + Math.random() * 0.3;
                    } else {
                        heartColors[i * 3] = 1;
                        heartColors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
                        heartColors[i * 3 + 2] = 0.3 + Math.random() * 0.3;
                    }

                    heartSizes[i] = Math.random() * 0.15 + 0.1;
                }

                heartGeometry.setAttribute('position', new THREE.BufferAttribute(heartPositions, 3));
                heartGeometry.setAttribute('color', new THREE.BufferAttribute(heartColors, 3));
                heartGeometry.setAttribute('size', new THREE.BufferAttribute(heartSizes, 1));

                const heartMaterial = new THREE.PointsMaterial({
                    size: 0.15,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const heartParticles = new THREE.Points(heartGeometry, heartMaterial);
                heartParticles.scale.set(2, 2, 2);
                
                // Create a group to hold all rotatable objects
                const sceneGroup = new THREE.Group();
                sceneGroup.add(heartParticles);

                // Galaxy
                const galaxyParticlesCount = 8000;
                const galaxyGeometry = new THREE.BufferGeometry();
                const galaxyPositions = new Float32Array(galaxyParticlesCount * 3);
                const galaxyColors = new Float32Array(galaxyParticlesCount * 3);

                for (let i = 0; i < galaxyParticlesCount; i++) {
                    const radius = Math.random() * 25 + 5;
                    const spinAngle = radius * 0.3;
                    const branchAngle = ((i % 3) / 3) * Math.PI * 2;

                    const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 0.5;
                    const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 0.5;
                    const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 0.5;

                    galaxyPositions[i * 3] = Math.cos(branchAngle + spinAngle) * radius + randomX;
                    galaxyPositions[i * 3 + 1] = randomY * 0.5;
                    galaxyPositions[i * 3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ;

                    const mixedColor = new THREE.Color();
                    const innerColor = new THREE.Color('#ff1493');
                    const middleColor = new THREE.Color('#9d4edd');
                    const outerColor = new THREE.Color('#ffd700');

                    const distanceRatio = radius / 30;
                    
                    if (distanceRatio < 0.33) {
                        mixedColor.lerpColors(innerColor, middleColor, distanceRatio * 3);
                    } else if (distanceRatio < 0.66) {
                        mixedColor.lerpColors(middleColor, outerColor, (distanceRatio - 0.33) * 3);
                    } else {
                        mixedColor.copy(outerColor);
                    }

                    galaxyColors[i * 3] = mixedColor.r;
                    galaxyColors[i * 3 + 1] = mixedColor.g;
                    galaxyColors[i * 3 + 2] = mixedColor.b;
                }

                galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(galaxyPositions, 3));
                galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(galaxyColors, 3));

                const galaxyMaterial = new THREE.PointsMaterial({
                    size: 0.08,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const galaxy = new THREE.Points(galaxyGeometry, galaxyMaterial);
                sceneGroup.add(galaxy);

                // Sparkles
                const sparklesGeometry = new THREE.BufferGeometry();
                const sparklesCount = 500;
                const sparklesPos = new Float32Array(sparklesCount * 3);
                const sparklesColors = new Float32Array(sparklesCount * 3);

                for (let i = 0; i < sparklesCount * 3; i += 3) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 3 + Math.random() * 2;
                    
                    sparklesPos[i] = Math.cos(angle) * radius;
                    sparklesPos[i + 1] = (Math.random() - 0.5) * 4 - 0.5;
                    sparklesPos[i + 2] = Math.sin(angle) * radius;

                    if (Math.random() < 0.7) {
                        sparklesColors[i] = 1;
                        sparklesColors[i + 1] = 1;
                        sparklesColors[i + 2] = 1;
                    } else {
                        sparklesColors[i] = 1;
                        sparklesColors[i + 1] = 0.84;
                        sparklesColors[i + 2] = 0;
                    }
                }

                sparklesGeometry.setAttribute('position', new THREE.BufferAttribute(sparklesPos, 3));
                sparklesGeometry.setAttribute('color', new THREE.BufferAttribute(sparklesColors, 3));

                const sparklesMaterial = new THREE.PointsMaterial({
                    size: 0.12,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });

                const sparkles = new THREE.Points(sparklesGeometry, sparklesMaterial);
                sceneGroup.add(sparkles);

                // Stars
                const starsGeometry = new THREE.BufferGeometry();
                const starsCount = 2000;
                const starsPos = new Float32Array(starsCount * 3);
                const starsSizes = new Float32Array(starsCount);
                const starsColors = new Float32Array(starsCount * 3);

                for (let i = 0; i < starsCount; i++) {
                    const i3 = i * 3;
                    starsPos[i3] = (Math.random() - 0.5) * 150;
                    starsPos[i3 + 1] = (Math.random() - 0.5) * 150;
                    starsPos[i3 + 2] = (Math.random() - 0.5) * 150;
                    
                    starsSizes[i] = Math.random() * 0.3 + 0.1;
                    
                    const colorVariation = Math.random();
                    if (colorVariation < 0.8) {
                        starsColors[i3] = 1;
                        starsColors[i3 + 1] = 1;
                        starsColors[i3 + 2] = 1;
                    } else if (colorVariation < 0.9) {
                        starsColors[i3] = 1;
                        starsColors[i3 + 1] = 0.9;
                        starsColors[i3 + 2] = 0.8;
                    } else {
                        starsColors[i3] = 0.8;
                        starsColors[i3 + 1] = 0.9;
                        starsColors[i3 + 2] = 1;
                    }
                }

                starsGeometry.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
                starsGeometry.setAttribute('size', new THREE.BufferAttribute(starsSizes, 1));
                starsGeometry.setAttribute('color', new THREE.BufferAttribute(starsColors, 3));
                
                const starsMaterial = new THREE.PointsMaterial({
                    size: 0.2,
                    sizeAttenuation: true,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });
                const stars = new THREE.Points(starsGeometry, starsMaterial);
                sceneGroup.add(stars);
                
                // Add the group to the scene
                scene.add(sceneGroup);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);

                const pointLight1 = new THREE.PointLight(0xff1493, 3, 50);
                pointLight1.position.set(5, 3, 5);
                scene.add(pointLight1);

                const pointLight2 = new THREE.PointLight(0xffd700, 2, 50);
                pointLight2.position.set(-5, -3, 5);
                scene.add(pointLight2);

                camera.position.z = 10;
                camera.position.y = 1;

                // Mouse drag controls - rotate the entire scene instead of camera
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                let sceneRotation = { x: 0, y: 0 };

                const handleMouseDown = (event) => {
                    isDragging = true;
                    previousMousePosition = {
                        x: event.clientX,
                        y: event.clientY
                    };
                };

                const handleMouseMove = (event) => {
                    if (!isDragging) return;

                    const deltaX = event.clientX - previousMousePosition.x;
                    const deltaY = event.clientY - previousMousePosition.y;

                    sceneRotation.y += deltaX * 0.005;
                    sceneRotation.x += deltaY * 0.005;

                    sceneRotation.x = Math.max(-0.5, Math.min(0.5, sceneRotation.x));

                    previousMousePosition = {
                        x: event.clientX,
                        y: event.clientY
                    };
                };

                const handleMouseUp = () => {
                    isDragging = false;
                };

                renderer.domElement.addEventListener('mousedown', handleMouseDown);
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);

                // Touch controls for mobile
                const handleTouchStart = (event) => {
                    if (event.touches.length === 1) {
                        isDragging = true;
                        previousMousePosition = {
                            x: event.touches[0].clientX,
                            y: event.touches[0].clientY
                        };
                    }
                };

                const handleTouchMove = (event) => {
                    if (!isDragging || event.touches.length !== 1) return;

                    const deltaX = event.touches[0].clientX - previousMousePosition.x;
                    const deltaY = event.touches[0].clientY - previousMousePosition.y;

                    sceneRotation.y += deltaX * 0.005;
                    sceneRotation.x += deltaY * 0.005;

                    sceneRotation.x = Math.max(-0.5, Math.min(0.5, sceneRotation.x));

                    previousMousePosition = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY
                    };
                };

                const handleTouchEnd = () => {
                    isDragging = false;
                };

                renderer.domElement.addEventListener('touchstart', handleTouchStart);
                renderer.domElement.addEventListener('touchmove', handleTouchMove);
                renderer.domElement.addEventListener('touchend', handleTouchEnd);

                // Animation
                let time = 0;
                const animate = () => {
                    requestAnimationFrame(animate);
                    time += 0.01;

                    // Apply user rotation to entire scene group
                    sceneGroup.rotation.y = sceneRotation.y;
                    sceneGroup.rotation.x = sceneRotation.x;
                    
                    heartParticles.rotation.y += 0.003;
                    
                    const scale = 2 + Math.sin(time * 1.5) * 0.15;
                    heartParticles.scale.set(scale, scale, scale);

                    const positions = heartParticles.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += Math.sin(time + i) * 0.001;
                    }
                    heartParticles.geometry.attributes.position.needsUpdate = true;

                    galaxy.rotation.y += 0.0005;
                    galaxy.rotation.x = Math.sin(time * 0.1) * 0.1;

                    sparkles.rotation.y -= 0.002;
                    const sparklesPos = sparkles.geometry.attributes.position.array;
                    for (let i = 0; i < sparklesPos.length; i += 3) {
                        sparklesPos[i + 1] += Math.sin(time * 2 + i * 0.1) * 0.005;
                    }
                    sparkles.geometry.attributes.position.needsUpdate = true;

                    stars.rotation.y += 0.0002;
                    stars.rotation.x += 0.0001;

                    pointLight1.position.x = Math.sin(time * 0.7) * 6;
                    pointLight1.position.z = Math.cos(time * 0.7) * 6;
                    pointLight2.position.x = Math.cos(time * 0.5) * 6;
                    pointLight2.position.z = Math.sin(time * 0.5) * 6;

                    renderer.render(scene, camera);
                };

                animate();

                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };

                window.addEventListener('resize', handleResize);

                const handleWheel = (event) => {
                    event.preventDefault();
                    const zoomSpeed = 0.1;
                    const delta = event.deltaY * -0.001;
                    const newZ = camera.position.z - delta * zoomSpeed * camera.position.z;
                    camera.position.z = Math.max(3, Math.min(20, newZ));
                };

                window.addEventListener('wheel', handleWheel, { passive: false });

                return () => {
                    window.removeEventListener('resize', handleResize);
                    window.removeEventListener('wheel', handleWheel);
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                    renderer.domElement.removeEventListener('mousedown', handleMouseDown);
                    renderer.domElement.removeEventListener('touchstart', handleTouchStart);
                    renderer.domElement.removeEventListener('touchmove', handleTouchMove);
                    renderer.domElement.removeEventListener('touchend', handleTouchEnd);
                    if (containerRef.current && renderer.domElement.parentNode === containerRef.current) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                    heartGeometry.dispose();
                    heartMaterial.dispose();
                    galaxyGeometry.dispose();
                    galaxyMaterial.dispose();
                    sparklesGeometry.dispose();
                    sparklesMaterial.dispose();
                    starsGeometry.dispose();
                    starsMaterial.dispose();
                    renderer.dispose();
                };
            }, []);

            const handleClick = (e) => {
                if (!isUserDragging && e.type === 'click') {
                    setShowMessage(true);
                    setCurrentMessage((prev) => (prev + 1) % messages.length);
                    setTimeout(() => setShowMessage(false), 7000); // Increased to 4 seconds
                }
            };

            const handleContainerMouseDown = (e) => {
                dragStartPos.current = { x: e.clientX, y: e.clientY };
                setIsUserDragging(false);
            };

            const handleContainerMouseMove = (e) => {
                const dx = e.clientX - dragStartPos.current.x;
                const dy = e.clientY - dragStartPos.current.y;
                // Increased threshold from 5 to 15 pixels to be more forgiving
                if (Math.abs(dx) > 15 || Math.abs(dy) > 15) {
                    setIsUserDragging(true);
                }
            };

            return h('div', {
                onClick: handleClick,
                onMouseDown: handleContainerMouseDown,
                onMouseMove: handleContainerMouseMove,
                style: {
                    width: '100vw',
                    height: '100vh',
                    margin: 0,
                    padding: 0,
                    overflow: 'hidden',
                    background: 'radial-gradient(ellipse at center, #0a0015 0%, #1a0033 50%, #000000 100%)',
                    cursor: 'pointer',
                    position: 'relative'
                }
            },
                h('div', { ref: containerRef, style: { width: '100%', height: '100%' } }),
                h('div', {
                    style: {
                        position: 'absolute',
                        top: '40px',
                        left: '50%',
                        transform: 'translateX(-50%)',
                        color: '#fff',
                        fontSize: '48px',
                        fontFamily: 'Georgia, serif',
                        textAlign: 'center',
                        textShadow: '0 0 20px rgba(255, 105, 180, 0.8), 0 0 40px rgba(255, 20, 147, 0.6)',
                        fontWeight: 'bold',
                        zIndex: 10
                    }
                }, 'Para Mau ðŸ’•'),
                h('div', {
                    style: {
                        position: 'absolute',
                        bottom: '40px',
                        left: '50%',
                        transform: 'translateX(-50%)',
                        color: '#fff',
                        fontSize: '18px',
                        fontFamily: 'Arial, sans-serif',
                        textAlign: 'center',
                        textShadow: '0 0 10px rgba(255, 215, 0, 0.8)',
                        zIndex: 10,
                        opacity: 0.8
                    }
                }, ),
                showMessage && h('div', {
                    style: {
                        position: 'absolute',
                        top: '50%',
                        left: '50%',
                        transform: 'translate(-50%, -50%)',
                        background: 'rgba(255, 20, 147, 0.9)',
                        padding: '40px 60px',
                        borderRadius: '30px',
                        color: '#fff',
                        fontSize: '32px',
                        fontFamily: 'Georgia, serif',
                        textAlign: 'center',
                        boxShadow: '0 0 40px rgba(255, 105, 180, 0.8), 0 0 80px rgba(255, 20, 147, 0.6)',
                        zIndex: 100,
                        animation: 'fadeInOut 7s ease-in-out',
                        maxWidth: '80%',
                        border: '3px solid rgba(255, 215, 0, 0.6)'
                    }
                }, messages[currentMessage])
            );
        }

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(h(ParaMau));
    </script>
</body>
</html>
